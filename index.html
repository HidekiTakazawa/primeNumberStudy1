<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>素数・整数論アプリ</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 20px auto;
      padding: 0 15px;
      background-color: #f4f4f4;
    }

    h1, h2 {
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
    }

    nav {
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
    }

    .tab-button {
      padding: 10px 15px;
      border: 1px solid #ccc;
      background-color: #fff;
      cursor: pointer;
      font-size: 16px;
      margin-right: 5px;
      margin-bottom: 5px;
      border-radius: 5px 5px 0 0;
      transition: background-color 0.3s, color 0.3s;
    }

    .tab-button.active {
      background-color: #3498db;
      color: white;
      border-bottom: 1px solid #3498db;
    }

    .tab-button:not(.active):hover {
      background-color: #ecf0f1;
    }

    section {
      background-color: #fff;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .hidden {
      display: none;
    }

    .form-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    input[type="text"] {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    button {
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #2980b9;
    }
    
    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }

    .result-box {
      margin-top: 20px;
      padding: 15px;
      background-color: #ecf0f1;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      word-wrap: break-word;
      white-space: pre-wrap;
      font-family: monospace;
    }
    
    .result-box h3 {
        margin-top: 0;
        font-family: sans-serif;
    }

    textarea {
      width: 100%;
      height: 150px;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: monospace;
    }

    .copy-button-container {
      text-align: right;
      margin-top: 10px;
    }

    .copy-feedback {
      color: green;
      font-size: 0.9em;
      margin-left: 10px;
    }

    .crt-input-grid {
      display: grid;
      grid-template-columns: auto 1fr 50px 1fr auto;
      gap: 5px 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .crt-input-grid span {
      text-align: center;
    }
  </style>
</head>

<body>
  <h1>素数・整数論アプリ</h1>

  <nav>
    <button class="tab-button active" data-tab="factorization">1. 素因数分解</button>
    <button class="tab-button" data-tab="primality-test">2. 素数判定</button>
    <button class="tab-button" data-tab="prime-generation">3. 素数作成</button>
    <button class="tab-button" data-tab="crt">4. 中国剰余定理</button>
  </nav>

  <main>
    <!-- 1. 素因数分解 -->
    <section id="factorization-section">
      <h2>素因数分解</h2>
      <div class="form-group">
        <label for="factorization-input">整数を入力してください</label>
        <input type="text" id="factorization-input" placeholder="例: 147">
      </div>
      <button id="factorize-button">素因数分解する</button>
      <div id="factorization-result" class="result-box" style="display: none;"></div>
    </section>

    <!-- 2. 素数判定 -->
    <section id="primality-test-section" class="hidden">
      <h2>素数判定 (ミラー・ラビン法)</h2>
      <div class="form-group">
        <label for="primality-test-input">判定したい整数を入力してください</label>
        <input type="text" id="primality-test-input" placeholder="例: 99991">
      </div>
      <button id="primality-test-button">判定する</button>
      <div id="primality-test-result" class="result-box" style="display: none;"></div>
    </section>

    <!-- 3. 素数作成 -->
    <section id="prime-generation-section" class="hidden">
      <h2>素数作成</h2>
      <div class="form-group">
        <label for="generate-start">範囲 (開始)</label>
        <input type="text" id="generate-start" placeholder="例: 100000">
      </div>
      <div class="form-group">
        <label for="generate-end">範囲 (終了)</label>
        <input type="text" id="generate-end" placeholder="例: 100100">
      </div>
       <div id="prime-estimation-result" class="result-box" style="display: none; margin-top: 0; margin-bottom: 15px;"></div>
      <button id="generate-primes-button">素数を作成する</button>
      <div id="prime-generation-result-container" class="result-box" style="display: none;">
        <h3>生成された素数一覧</h3>
        <textarea id="generated-primes-output" readonly></textarea>
        <div class="copy-button-container">
          <button id="copy-primes-button">クリップボードにコピー</button>
          <span id="copy-feedback" class="copy-feedback"></span>
        </div>
      </div>
    </section>

    <!-- 4. 中国剰余定理 -->
    <section id="crt-section" class="hidden">
        <h2>中国剰余定理</h2>
        <p>x ≡ a (mod p) となる連立合同式の解を求めます。<br>法 (p1, p2, ...) は互いに素である必要があります。</p>
        <div id="crt-inputs">
            <!-- 入力欄はJSで生成 -->
        </div>
        <button id="crt-solve-button">計算する</button>
        <div id="crt-result" class="result-box" style="display: none;"></div>
    </section>
  </main>
  <script src="primeTBL.js"></script>
  <script>
    

    const primeList = primeString ? primeString.split(", ").map(Number) : [];
    const primeListBigInt = primeList.map(p => BigInt(p));

    // --- ユーティリティ関数 ---
    function power(base, exp, mod) {
        let res = 1n;
        base %= mod;
        while (exp > 0n) {
            if (exp % 2n === 1n) res = (res * base) % mod;
            base = (base * base) % mod;
            exp /= 2n;
        }
        return res;
    }

    function gcd(a, b) {
        while (b) {
            [a, b] = [b, a % b];
        }
        return a;
    }

    function extendedEuclideanAlgorithm(a, b) {
        if (a === 0n) {
            return [b, 0n, 1n];
        }
        const [g, y, x] = extendedEuclideanAlgorithm(b % a, a);
        return [g, x - (b / a) * y, y];
    }

    function modInverse(a, m) {
        const [g, x, y] = extendedEuclideanAlgorithm(a, m);
        if (g !== 1n) {
            throw new Error('逆元は存在しません');
        }
        return (x % m + m) % m;
    }

    // --- 1. 素因数分解 ---
    function primeFactorize(numStr) {
        if (primeList.length === 0) return "素数リストが設定されていません。";
        try {
            let n = BigInt(numStr);
            if (n < 2n) return "2以上の整数を入力してください。";

            const factors = [];
            let tempN = n;

            for (const prime of primeListBigInt) {
                if (prime * prime > tempN) break;
                while (tempN % prime === 0n) {
                    factors.push(prime.toString());
                    tempN /= prime;
                }
            }
            if (tempN > 1n) {
                factors.push(tempN.toString());
            }
            
            if (factors.length === 1 && factors[0] === n.toString()) {
                return `${n} は素数です。`;
            }

            return `${n} = ${factors.join(' × ')}`;
        } catch (e) {
            return "有効な整数を入力してください。";
        }
    }

    // --- 2. 素数判定 (ミラー・ラビン法) ---
    function millerRabinTest(nStr) {
        try {
            const n = BigInt(nStr);
            
            if (n < 2n) return { result: "合成数", bases: [], message: "2以上の整数を入力してください。" };
            if (n === 2n || n === 3n) return { result: "素数", bases: [], message: "" };
            if (n % 2n === 0n) return { result: "合成数", bases: [], message: "2で割り切れます。" };

            let d = n - 1n;
            let s = 0n;
            while (d % 2n === 0n) {
                d /= 2n;
                s++;
            }

            const k = 20;
            const usedBases = new Set();
            const bases = [];

            for (let i = 0; i < k; i++) {
                let a;
                do {
                    const randomBytes = new Uint8Array(8);
                    crypto.getRandomValues(randomBytes);
                    const randomBigInt = randomBytes.reduce((acc, byte) => (acc << 8n) | BigInt(byte), 0n);
                    a = 2n + (randomBigInt % (n - 3n));
                } while (usedBases.has(a));
                
                usedBases.add(a);
                bases.push(a.toString());

                let x = power(a, d, n);
                if (x === 1n || x === n - 1n) continue;

                let isComposite = true;
                for (let r = 1n; r < s; r++) {
                    x = (x * x) % n;
                    if (x === n - 1n) {
                        isComposite = false;
                        break;
                    }
                }
                if (isComposite) {
                    return { result: "合成数", bases: bases, message: `基数 ${a} で合成数と判定されました。` };
                }
            }
            return { result: "おそらく素数", bases: bases, message: `${k}回のテストをクリアしました。` };

        } catch (e) {
            return { result: "エラー", bases: [], message: "有効な整数を入力してください。" };
        }
    }

    // --- 3. 素数作成 ---
    function generatePrimes(startStr, endStr) {
        try {
            const MAX_GENERATION_COUNT = 200;
            const start = BigInt(startStr);
            const end = BigInt(endStr);
            const MAX_PRECALCULATED_PRIME = 99991n;

            if (start > end) return "開始値は終了値以下にしてください。";
            if (end > 2n**64n - 1n) return "最大値は64ビット整数 (約1.84 x 10^19) までです。";

            const foundPrimes = [];

            if (end <= MAX_PRECALCULATED_PRIME) {
                if (primeList.length === 0) return "素数リストが設定されていません。";
                const startNum = Number(start);
                const endNum = Number(end);
                for (const p of primeList) {
                    if (p >= startNum && p <= endNum) {
                        foundPrimes.push(p);
                        if (foundPrimes.length >= MAX_GENERATION_COUNT) break;
                    }
                }
                return foundPrimes.slice(0, MAX_GENERATION_COUNT).join(', ');
            }

            if (start <= MAX_PRECALCULATED_PRIME) {
                 if (primeList.length === 0) return "素数リストが設定されていません。";
                 const startNum = Number(start);
                 for (const p of primeList) {
                    if (p >= startNum) {
                        foundPrimes.push(p);
                        if (foundPrimes.length >= MAX_GENERATION_COUNT) break;
                    }
                }
            }
            if (foundPrimes.length >= MAX_GENERATION_COUNT) {
                return foundPrimes.slice(0, MAX_GENERATION_COUNT).join(', ');
            }
            let current = start > MAX_PRECALCULATED_PRIME ? start : MAX_PRECALCULATED_PRIME + 1n;
            if (current % 2n === 0n) current++;

            while (current <= end && foundPrimes.length < MAX_GENERATION_COUNT) {
                const testResult = millerRabinTest(current.toString());
                if (testResult.result === "おそらく素数") {
                    foundPrimes.push(current);
                }
                current += 2n;
            }

            return foundPrimes.join(', ');
        } catch (e) {
            return "有効な範囲を整数で入力してください。";
        }
    }

    // --- 4. 中国剰余定理 ---
    function solveCRT(equations) {
        let output = "入力された合同式:\n";
        equations.forEach(eq => {
            output += `x ≡ ${eq.a} (mod ${eq.p})\n`;
        });
        output += "\n--- 途中計算 ---\n";

        const moduli = equations.map(eq => eq.p);
        for (let i = 0; i < moduli.length; i++) {
            for (let j = i + 1; j < moduli.length; j++) {
                if (gcd(moduli[i], moduli[j]) !== 1n) {
                    return `エラー: 法 ${moduli[i]} と ${moduli[j]} は互いに素ではありません。`;
                }
            }
        }

        const n = moduli.reduce((acc, val) => acc * val, 1n);
        output += `1. 全体の法 n の計算:\n   n = ${moduli.join(' * ')} = ${n}\n\n`;

        output += "2. 各 N_i とその逆元 N_i_inv の計算:\n";
        let sum = 0n;
        const terms = [];

        for (let i = 0; i < equations.length; i++) {
            const { a, p } = equations[i];
            const Ni = n / p;
            const Ni_inv = modInverse(Ni, p);
            
            output += `   - i=${i+1} (mod ${p}):\n`;
            output += `     N_${i+1} = n / ${p} = ${Ni}\n`;
            output += `     ${Ni} * N_${i+1}_inv ≡ 1 (mod ${p})  =>  ${Ni % p} * N_${i+1}_inv ≡ 1 (mod ${p})\n`;
            output += `     N_${i+1}_inv = ${Ni_inv}\n\n`;
            
            const term = a * Ni * Ni_inv;
            terms.push({ text: `${a}*${Ni}*${Ni_inv}`, value: term });
            sum += term;
        }

        output += "3. 解 A の計算:\n";
        output += `   A = (${terms.map(t => t.text).join(' + ')}) mod ${n}\n`;
        output += `   A = (${terms.map(t => t.value).join(' + ')}) mod ${n}\n`;
        output += `   A = ${sum} mod ${n}\n`;
        const result = sum % n;
        output += `   A = ${result}\n\n`;

        output += `--- 解 ---\nx ≡ ${result} (mod ${n})`;
        return output;
    }

    // --- UI制御とイベントリスナー ---
    document.addEventListener('DOMContentLoaded', () => {
        const tabs = document.querySelectorAll('.tab-button');
        const sections = {
            'factorization': document.getElementById('factorization-section'),
            'primality-test': document.getElementById('primality-test-section'),
            'prime-generation': document.getElementById('prime-generation-section'),
            'crt': document.getElementById('crt-section')
        };

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                Object.values(sections).forEach(s => s.classList.add('hidden'));
                sections[tab.dataset.tab].classList.remove('hidden');
            });
        });

        // 1. 素因数分解
        const factorizeBtn = document.getElementById('factorize-button');
        const factorizationInput = document.getElementById('factorization-input');
        const factorizationResult = document.getElementById('factorization-result');
        factorizeBtn.addEventListener('click', () => {
            const num = factorizationInput.value.trim();
            if (!num) return;
            const result = primeFactorize(num);
            factorizationResult.textContent = result;
            factorizationResult.style.display = 'block';
        });

        // 2. 素数判定
        const primalityTestBtn = document.getElementById('primality-test-button');
        const primalityTestInput = document.getElementById('primality-test-input');
        const primalityTestResult = document.getElementById('primality-test-result');
        primalityTestBtn.addEventListener('click', () => {
            const num = primalityTestInput.value.trim();
            if (!num) return;
            const { result, bases, message } = millerRabinTest(num);
            primalityTestResult.innerHTML = `<h3 style="font-family: sans-serif;">判定結果: ${result}</h3>
                <p style="font-family: sans-serif;">${message}</p>
                <p style="font-family: sans-serif;">使用した基数a (${bases.length}個): ${bases.join(', ')}</p>`;
            primalityTestResult.style.display = 'block';
        });

        // 3. 素数作成
        const generatePrimesBtn = document.getElementById('generate-primes-button');
        const generateStartInput = document.getElementById('generate-start');
        const generateEndInput = document.getElementById('generate-end');
        const resultContainer = document.getElementById('prime-generation-result-container');
        const generatedPrimesOutput = document.getElementById('generated-primes-output');
        const estimationResult = document.getElementById('prime-estimation-result');
        const copyPrimesBtn = document.getElementById('copy-primes-button');
        const copyFeedback = document.getElementById('copy-feedback');
        generatePrimesBtn.addEventListener('click', () => {
            const start = generateStartInput.value.trim();
            const end = generateEndInput.value.trim();
            if (!start || !end) return;
            generatePrimesBtn.disabled = true;
            generatePrimesBtn.textContent = '作成中...';
            resultContainer.style.display = 'none';
            setTimeout(() => {
                const result = generatePrimes(start, end);
                generatedPrimesOutput.value = result;
                resultContainer.style.display = 'block';
                generatePrimesBtn.disabled = false;
                generatePrimesBtn.textContent = '素数を作成する';
            }, 10);
        });
        copyPrimesBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(generatedPrimesOutput.value).then(() => {
                copyFeedback.textContent = 'コピーしました！';
                setTimeout(() => { copyFeedback.textContent = ''; }, 2000);
            }).catch(err => {
                copyFeedback.textContent = 'コピーに失敗しました。';
            });
        });
        const estimatePrimeCount = () => {
            const startStr = generateStartInput.value.trim();
            const endStr = generateEndInput.value.trim();

            if (!startStr || !endStr) {
                estimationResult.style.display = 'none';
                return;
            }

            try {
                const start = BigInt(startStr);
                const end = BigInt(endStr);

                if (start > end || start < 0n) {
                    estimationResult.style.display = 'none';
                    return;
                }

                const primePi = (n) => {
                    if (n < 2) return 0;
                    // 大きな数ではNumberの精度限界により不正確になる可能性があります
                    const num = Number(n);
                    return num / Math.log(num);
                };

                const count = Math.round(primePi(end) - primePi(start));
                estimationResult.textContent = `この範囲にはおよそ ${count.toLocaleString()} 個の素数が存在すると推定されます。(上限200個まで生成)`;
                estimationResult.style.display = 'block';
            } catch (e) {
                estimationResult.style.display = 'none';
            }
        };
        generateStartInput.addEventListener('input', estimatePrimeCount);
        generateEndInput.addEventListener('input', estimatePrimeCount);

        // 4. 中国剰余定理
        const crtInputsContainer = document.getElementById('crt-inputs');
        const crtSolveBtn = document.getElementById('crt-solve-button');
        const crtResult = document.getElementById('crt-result');
        for (let i = 1; i <= 5; i++) {
            const div = document.createElement('div');
            div.className = 'crt-input-grid';
            div.innerHTML = `
                <span>x ≡</span>
                <input type="text" id="crt-a${i}" placeholder="a${i}">
                <span>(mod</span>
                <input type="text" id="crt-p${i}" placeholder="p${i}">
                <span>)</span>
            `;
            crtInputsContainer.appendChild(div);
        }
        crtSolveBtn.addEventListener('click', () => {
            const equations = [];
            let error = false;
            for (let i = 1; i <= 5; i++) {
                const aStr = document.getElementById(`crt-a${i}`).value.trim();
                const pStr = document.getElementById(`crt-p${i}`).value.trim();
                if (aStr && pStr) {
                    try {
                        const a = BigInt(aStr);
                        const p = BigInt(pStr);
                        if (p <= 1n) {
                            crtResult.textContent = `エラー: 法 p${i} は1より大きい整数である必要があります。`;
                            error = true;
                            break;
                        }
                        equations.push({ a, p });
                    } catch (e) {
                        crtResult.textContent = 'エラー: 有効な整数を入力してください。';
                        error = true;
                        break;
                    }
                }
            }
            if (error) {
                crtResult.style.display = 'block';
                return;
            }
            if (equations.length < 2) {
                crtResult.textContent = '少なくとも2つの合同式を入力してください。';
                crtResult.style.display = 'block';
                return;
            }
            const result = solveCRT(equations);
            crtResult.textContent = result;
            crtResult.style.display = 'block';
        });
    });
  </script>

</body>
</html>